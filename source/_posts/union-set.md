title: 并查集
author: Monody12
tags:
  - union set
categories:
  - algorithm
date: 2021-05-04 21:12:00
---
目录
1. 应用场景
2. 实现方式
3. 举例分析

## 1.应用场景
在什么情况下需要使用并查集？
通常情况下在进行集合合并操作时，我们会将一个集合A中的元素全部导入另一个集合B。那么怎样导入呢，是把集合A的元素一个一个的拿出来依次加入集合B，加入的时候使用set或者hashset。在数据量比较小的情况下，这样是行得通的。如果数据量很大，并且一堆集合需要反复合并。其中一些元素可能被来回加入取出很多次，花费很多时间。这时候并查集就派上用场了。

简而言之：大量的**集合合并**操作

## 2.实现方式
### 核心思想
可以把元素之间用一个线连接起来，形成一个连通块，这个连通块不就是一个集合吗？那么我们在合并两个集合的时候将这两个连通块中的任意一个元素拿出来然后用线连接起来，这样两个连通块就变成了一个连通块，就实现了集合合并。

而并查集实现以上介绍的方法非常巧妙。它使用了父元素的方式来记录当前元素是属于哪个元素的集合。即p[x]表示为x的父元素。而如果p[x]==x则表示这个集合的根（集合的根可以想象为这个集合的中心）就是x。合并集合就是将这个集合的根指向另一个集合的元素（通常写的时候直接指向根了）。

### 主要操作
摘自[百度百科](https://baike.baidu.com/item/%E5%B9%B6%E6%9F%A5%E9%9B%86/9388442?fr=aladdin#1)  
#### 初始化  
把每个点所在集合初始化为其自身。  `p[i] = i;`
通常来说，这个步骤在每次使用该数据结构时只需要执行一次，无论何种实现方式，时间复杂度均为O(N)。  
#### 查找  
查找元素x所在的集合，即根节点。 编写find(int x)函数 (到后面再介绍)
#### 合并  
将两个元素所在的集合合并为一个集合。  `p[find(x)] = find(y);`  
通常来说，合并之前，应先判断两个元素是否属于同一集合，这可用上面的“查找”操作实现。

### 优化
在查找一个集合的根时，如果这个集合中有大量的元素，而查询的元素又是距离根根元素最远的，那么经常查询，势必又会消耗大量的时间。那么有办法能让我们的元素尽可能的离根元素近吗？当然能！

#### 路径压缩
使用路径压缩优化，可以在查询当前元素的根元素的时候直接把路径上的元素的父元素直接**指向根元素**，这样以来，并查集就呈现出了中心趋势，所有除根元素以外的元素都直接指向根元素了。
```c++
	int find(int x) {//查找元素x所属集合的根节点
		if (p[x] != x)
			p[x] = find(p[x]);//查找父亲结点，顺带 路径压缩 优化
		return p[x];
}

```
