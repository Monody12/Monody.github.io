title: 第九届蓝桥杯大赛软件类省赛 C/C++ 大学B 组
author: Monody12
tags:
  - Blue Bridge Cup
  - bfs
  - modulus
  - excel
  - binary
  - quick sort
  - bucket sorting
  - prefix sum
  - greedy
categories:
  - algorithm
date: 2021-04-05 21:08:00
---
## <a name="目录">目录</a>
1. [第几天](#第几天)
2. [明码](#明码)
3. [乘积尾零](#乘积尾零)
4. [测试次数](#测试次数)
5. [快速排序](#快速排序)
6. [递增三元组](#递增三元组)
7. [螺旋折线](#螺旋折线)
8. [日志统计](#日志统计)
9. [全球变暖](#全球变暖)
10. [乘积最大](#乘积最大)

## <a name="第几天">第几天 (excel)</a>   
2000年的1月1日，是那一年的第1天。  
那么，2000年的5月4日，是那一年的第几天？
### 解法
使用excel输入两个日期，利用日期间隔函数（DATEDIF）来求出两个日期之间相差的天数。  
注意：“d”表示求两日期之间的天数（days）差。由于1月1日当天也符合题目要求，所以答案需要+1 。  
![excel日期间隔函数.jpg](https://i.loli.net/2021/04/06/qFtPNURTpsWfvnJ.jpg)
答案为：125


[返回顶部](#目录)

-------

## <a name="明码">明码 (二进制)</a> 
汉字的字形存在于字库中，即便在今天，16点阵的字库也仍然使用广泛。
16点阵的字库把每个汉字看成是16x16个像素信息。并把这些信息记录在字节中。

一个字节可以存储8位信息，用32个字节就可以存一个汉字的字形了。
把每个字节转为2进制表示，1表示墨迹，0表示底色。每行2个字节，
一共16行，布局是：

    第1字节，第2字节
    第3字节，第4字节
    ....
    第31字节, 第32字节

这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。

题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求填写答案。

这段信息是（一共10个汉字）：
```
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
16 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 16 
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
0 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 4 
4 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 64 
16 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -128 
0 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 0 
2 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 0 
1 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 0 
0 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0 
```

注意：需要提交的是一个整数，不要填写任何多余内容。

### 解法
我觉得本题最主要考察的是**阅读理解**，其次才是二进制转换。  
由题意得：一个汉字有16\*16像素组成的点阵，每个像素可以看成一个二进制位。0表示底色，1表示墨迹（可以理解为1就是用笔写在纸上的墨迹，0就是空白的部分）。每个字节有8个二进制位，一个汉字的一行需要两个字节，共需要16行。  
题中给的数据：每一行表示一个字的32字节，我们需要每次读取两个字节然后进行转换，最后输出一行墨迹。  
二进制转换：我这里使用了C++的bitset直接将一个整数转换为二进制，再通过to_string转为可以识别的字符串，非常方便！  
手动转二进制可以参考[该题解](https://blog.csdn.net/sugarbliss/article/details/79790271)，很详细！


```c++
#include <cstdio>
#include <bitset>
#include <string>
#include <cmath>

#define input freopen("C:\\Users\\Administrator\\Desktop\\a.txt","r",stdin)

using namespace std;

int a[10][32];

void print(bitset<8> &bit) { //输出该字节对应的字形
    string t = bit.to_string();
    for (char i : t) {
        if (i == '1')
            printf("*");
        else
            printf(" ");
    }
}

int main() {
    input;
    int n = 10, m = 32;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < 32; ++j)
            scanf("%d", &a[i][j]);
    for (int i = 0; i < 10; ++i) {
        int index = 0;
        for (int j = 0; j < 16; ++j) {
            bitset<8> bit1(a[i][index++]); //每一行有两个字节组成, 读入两个字节
            bitset<8> bit2(a[i][index++]);
            print(bit1);
            print(bit2);
            printf("\n");
        }
        printf("\n");
    }
    printf("9的9次方等于: %.0lf", pow(9, 9));
    return 0;
}
```
输出答案: 387420489
```
     *
     *
     *
     *    *
************
     *    *
     *    *
     *    *
     *    *
     *    *
    *     *
    *     *
   *      *   *
   *      *   *
  *        ****
**

   *     *
   *     *
  *   *  *   *
 ******* ******
 *    * *    *
 *    **     *
 *    *      *
 *    * *    *
 ******  **  *
 *    *   *  *
 *    *      *
 *    *      *
 *    *      *
 ******      *
 *    *   * *
           *

     *
     *
     *
     *    *
************
     *    *
     *    *
     *    *
     *    *
     *    *
    *     *
    *     *
   *      *   *
   *      *   *
  *        ****
**

        *
 *      *
  **    *
   *   *    *
       *******
      *     *
    *    * *
   *     *
  *      *
***      *
  *     * *
  *     * *
  *    *   *
  *   *     *
  *  *      ***
  * *        *

     *
      **
       *
             *
***************
     *
     *     *
     ********
     *     *
     *     *
     *     *
    *      *
    *      *
   *       *
  *     * *
 *       *

   *     *
   * *   *  *
  ***** ******
 *  *  *  *
     * *   *
       *
  ***********
       *
***************
         *
         * *
  ***********
    *    *
     *   *
       * *
        *

           *
  ***********
       *
       *
       *
       *     *
***************
       *
       *
       *
       *
       *
       *
       *
     * *
      *

      *
      *
     *******
    *     *
   **    *
  *  * **
      * *
    **  *
 ***   *******
      *     *
    **     *
   *  *   *
  *    ***
       *
    ***
 ***

       *
       *
       *
    *  *  *
    *  *   *
   *   *    **
   *   *     *
  *    *   *
 *     *   *
       *  *
       * *
        *
       *
      *
    **
 ***



     *******
   **      **
  **        **
  ***       **
          ***
        ***
        **
        *


       **
      ****
       **

```
9的9次方等于: 387420489



[返回顶部](#目录)

-------

## <a name="乘积尾零">乘积尾零 （取模）</a>
如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？ 

```
5650 4542 3554 473 946 4114 3871 9073 90 4329 
2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 
9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 
1486 5722 3135 1170 4014 5510 5120 729 2880 9019 
2049 698 4582 4346 4427 646 9742 7340 1230 7683 
5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 
6701 6645 1671 5978 2704 9926 295 3125 3878 6785 
2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 
3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 
689 5510 8243 6114 337 4096 8199 7313 3685 211 
```

注意：需要提交的是一个整数，表示末尾零的个数。不要填写任何多余内容。

### 解法
1. 直接进行大数乘法运算，比如使用C/C++高精度乘法（太复杂，不推荐），Java的BigInteger，Python。然后找出运算结果末尾0的个数。
2. 数学——分解因式。由于需要查找末尾0的个数，也就是有多少个10这个因子。但是10这个因子是由2和5相乘得来的，所以在进行乘积运算时只需要找出这100个整数中2的因子和5的因子。2和5的个数中，其中一个数的最小值决定了能产生10的个数。

```C++
#include <cstdio>
#include <algorithm>

#define input freopen("C:\\Users\\Administrator\\Desktop\\a.txt","r",stdin)

using namespace std;

int main() {
    input;
    int n;
    int fac_2 = 0, fac_5 = 0; //所有数中含有2和5的因数个数
    for (int i = 0; i < 100; ++i) {
        scanf("%d", &n);
        while (n && n % 2 == 0) {
            ++fac_2;
            n /= 2;
        }
        while (n && n % 5 == 0) {
            ++fac_5;
            n /= 5;
        }
    }
    printf("%d", min(fac_2, fac_5));
    return 0;
}
```
[返回顶部](#目录)

-------

## <a name="测试次数">测试次数</a>
[参见](http://www.manongjc.com/detail/18-qmghnotunghkkhc.html)  
[返回顶部](#目录)

-------

## <a name="快速排序">快速排序</a>

以下代码可以从数组a[ ]中找出第k小的元素。

它使用了类似快速排序中的分治算法，期望时间复杂度是O(N)的。

请仔细阅读分析源码，填写划线部分缺失的内容。
```c
#include <stdio.h>

int quick_select(int a[], int l, int r, int k) {
	int p = rand() % (r - l + 1) + l;
	int x = a[p];
	{int t = a[p]; a[p] = a[r]; a[r] = t;}
	int i = l, j = r;
	while(i < j) {
		while(i < j && a[i] < x) i++;
		if(i < j) {
			a[j] = a[i];
			j--;
		}
		while(i < j && a[j] > x) j--;
		if(i < j) {
			a[i] = a[j];
			i++;
		}
	}
	a[i] = x;
	p = i;
	if(i - l + 1 == k) return a[i];
	if(i - l + 1 < k) return quick_select( _____________________________ ); //填空
	else return quick_select(a, l, i - 1, k);
}
	
int main()
{
	int a[] = {1, 4, 2, 8, 5, 7, 23, 58, 16, 27, 55, 13, 26, 24, 12};
	printf("%d\n", quick_select(a, 0, 14, 5));
	return 0;
}
```
参考[题解](https://blog.csdn.net/weixin_43378573/article/details/107708931)
```java
//9、通过算式i - l + 1得到的是在数组中第几小的元素，若它等于k，则得到题目要求的数组a[]中第k小的元素
        if (i - l + 1 == k)
            return a[i];
        //若小于k,即我们所求的元素在i的右边，此时左指针指向的元素为a[p+1],右指针指向的元素依旧是a[r],所求第k小的元素变为第k - (i - l + 1)小
        if (i - l + 1 < k)
            return quickSelect(a, i + 1, r, k - (i - l + 1)); // 填空
        else
            //若大于k,即我们所求的元素在i的左边，此时左指针指向的元素为认为a[l],右指针指向的元素为a[i-1]，仍旧是求第k小的元素
            return quickSelect(a, l, i - 1, k);
```

答案: k - (i - l + 1)


注意：只填写划线部分缺少的代码，不要抄写已经存在的代码或符号。
[返回顶部](#目录)

-------

## <a name="递增三元组">递增三元组 (桶排序 前缀和 乘法原理)</a>
标题：递增三元组

给定三个整数数组  
A = [A1, A2, ... AN],   
B = [B1, B2, ... BN],   
C = [C1, C2, ... CN]，  
请你统计有多少个三元组(i, j, k) 满足：  
1. 1 <= i, j, k <= N    
2. Ai < Bj < Ck    

【输入格式】   
第一行包含一个整数N。 
第二行包含N个整数A1, A2, ... AN。  
第三行包含N个整数B1, B2, ... BN。  
第四行包含N个整数C1, C2, ... CN。  

对于30%的数据，1 <= N <= 100    
对于60%的数据，1 <= N <= 1000   
对于100%的数据，1 <= N <= 100000 0 <= Ai, Bi, Ci <= 100000   

【输出格式】  
一个整数表示答案  

【样例输入】  
3  
1 1 1  
2 2 2   
3 3 3  

【样例输出】  
27    

### 题意
依次在三个数组中找到递增的三个数组成三元组，这三元组可以有重复的。
### 分析
根据数据规模发现，枚举第一或第三数组都是不可取的，时间复杂度至少n2。那就枚举第二个数组。目标就更清晰了，枚举第二数组：在第一个数组中找到比它小的数，在第三数组中找到比它大的数，根据乘法原理，可以组成的元组个数为第一个数组能找到的数和第三数组能找到的数的乘积之和。  

### 实现
找数可以通过 桶排序+前缀O(n)和或者是二分O(nlogn)来做。  
这里我选择了前者。  
前缀和需要使数组首位元素为0, 所以将所有数字都+1, 不会影响结果。   


```c
#include <stdio.h>

#define input freopen("C:\\Users\\Administrator\\Desktop\\a.txt","r",stdin)

#define maxn 100002
int bucket_a[maxn], b[maxn], bucket_c[maxn], sum_a[maxn], sum_b[maxn], sum_c[maxn];

void read(int *arr, int n) {  //桶排序 读入并存储该元组的数
    int x;
    for (int i = 0; i < n; ++i) {
        scanf("%d", &x);
        ++x; //将读入的数进行+1处理方便前缀和处理
        ++arr[x];
    }
}

void sum(const int *arr, int *sum_arr) { //计算前缀和
    for (int i = 1; i < 100002; ++i) { //值域为100000+1
        sum_arr[i] = arr[i] + sum_arr[i - 1];
    }
}

int main() {
   // input;
    int n;
    scanf("%d", &n);
    read(bucket_a, n);
    for (int i = 0; i < n; ++i)
        scanf("%d", b + i);
    read(bucket_c, n);
    sum(bucket_a, sum_a), sum(bucket_c, sum_c);////sum_a[i] :表示在a元组中小于i的数有a[i]个
    long long ans = 0;
    for (int i = 0; i < n; ++i) {
        int t = b[i] + 1; //b元组中的数 记得数值+1
        ans += (long long) sum_a[t - 1] * (sum_c[maxn - 1] - sum_c[t]);  ////sum_a[t-1]为a元组中比t小的数, sum_c[maxn - 1] - sum_c[t]为c元组中比t大的数
    }
    printf("%lld", ans);
    return 0;
}
```
[返回顶部](#目录)

-------

## <a name="螺旋折线">螺旋折线</a>
[返回顶部](#目录)

-------

## <a name="日志统计">日志统计</a>
[返回顶部](#目录)

-------

## <a name="全球变暖">全球变暖 （bfs）</a>  
你有一张某海域NxN像素的照片，"."表示海洋、"#"表示陆地，如下所示：  
```
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中"上下左右"四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。    

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。      

例如上图中的海域未来会变成如下样子：
```
.......  
.......  
.......  
.......  
....#..  
.......  
.......  
```
请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。  

【输入格式】
第一行包含一个整数N。  (1 <= N <= 1000)  
以下N行N列代表一张海域照片。  

照片保证第1行、第1列、第N行、第N列的像素都是海洋。  

【输出格式】
一个整数表示答案。

【输入样例】
```
7 
.......
.##....
.##....
....##.
..####.
...###.
.......  
```

【输出样例】
1  


### 题意
题目要求岛屿是否会完全消失，可以转化为岛屿的占位点和边界点是否相等。如果相等则说明岛屿全是边界点，会随着变暖而消失。

```c++
#include <cstdio>
#include <queue>
#include <algorithm>

using namespace std;
char mp[1001][1001];
bool vis[1001][1001];
int dr[][2] = {{1,  0},
               {-1, 0},
               {0,  1},
               {0,  -1}};

/*判断当前岛屿是否会消失*/
bool bfs(int x, int y, int n) {
    int points = 0, boundary = 0; //记录当前岛屿的 点 数和 边界点 数
    queue<pair<int, int>> q;
    q.push({x, y});
    while (!q.empty()) {
        x = q.front().first, y = q.front().second;
        q.pop();
        vis[x][y] = true;
        int is_boundary = 0; //如果这个点周围累计了四个点, 则不是边界
        for (int i = 0; i < 4; ++i) {
            int dx = x + dr[i][0], dy = y + dr[i][1];
            if (dx < 0 || dy < 0 || dx >= n || dy >= n || mp[dx][dy] == '.')
                continue;
            ++is_boundary;
            if (!vis[dx][dy])
                q.push({dx, dy});
        }
        if (is_boundary < 4) //如果没有四个点环绕, 则说明这个点是边界点
            ++boundary;
        ++points;
    }
    return points == boundary;
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i)
        scanf("%s", mp[i]);
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (!vis[i][j] && mp[i][j] == '#')
                if (bfs(i, j, n))
                    ++ans;
        }
    }
    printf("%d", ans);
    return 0;
}
```
[返回顶部](#目录)

-------

## <a name="乘积最大">乘积最大（贪心）</a>
### 需要分类讨论
1. n==k  
把所有数全部选择。  
2. n<k 且 k为偶数  
至少存在一种选择使得答案大于等于0。因为每次拿出一对数进行乘积，只要这对数是同号的，那么就不会出现负数。  
3. n<k 且 k为奇数  
拿出一个尽量大的数后，就可以转为第二种情况。    
**尽量大的数**（贪心）：如果数列中最大的数为正数，那么就选它。如果数列中最大的数为负数，那么就选值最大的负数（也就是绝对值最小的负数）。  
**选数策略**（也是贪心）：将给出的数列进行升序排序，乘积绝对值最大的数对可能分布在最左端或最右端。如果当前最大的数ans是正数，那么就选数值大的数对，反之选数值小的数对。（每次选取都满足局部最优，可以尝试举反例验证）    

```c++
#include <cstdio>
#include <string>
#include <algorithm>

using namespace std;

typedef long long ll;
int a[100001], n, k, mod = 1000000009;

ll select_all() {
    long long ans = 1;
    for (int i = 0; i < n; ++i) {
        ans = (a[i] * ans) % mod;
    }
    return ans;
}

/**
 * (贪心) 返回值第一参数为左右两组数中较大的一个, 第二参数1表示左边大,0表示右边大
 * @param leftIndex 左指针
 * @param rightIndex 右指针
 * @param ans 当前的最大值
 * @return pair中的first为可以与ans相乘组成的最大的数 ,second为判断标记是1则表示应取左边的一对, 0则为应取右边的一对
 */
pair<ll, int>
select_twoValue_larger(int leftIndex, int rightIndex, int ans) {
    ll left = (ll) a[leftIndex] * a[leftIndex + 1];
    ll right = (ll) a[rightIndex] * a[rightIndex - 1];
    ll max_value = ans > 0 ? max(left, right) : min(left, right); //如果当前ans为正数, 则选最大的一对的乘积, 反之选最小的
    return {max_value, max_value == left};
}


int main() {
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; ++i) {
        scanf("%d", a + i);
    }
    sort(a, a + n);
    ll ans = 1;
    if (n == k) { //全选
        printf("%lld", select_all());
    } else {
        int l = 0, r = n - 1, select_num = 0; //双指针
        if (k % 2 == 1) { //如果k为奇数, 尽量选择一个最大的正数
            ans = a[r];
            --r;
            ++select_num;
        }
        while (select_num < k && r >= l) {  //贪心 每次选出能使ans获得最大乘积的一对数
            pair<ll, int> t = select_twoValue_larger(l, r, ans);
            if (t.second == 1)
                l += 2;
            else
                r -= 2;
            select_num += 2;
            ans = t.first % mod * ans % mod;
        }
    }
    printf("%lld", ans % mod);
    return 0;
}

```
[返回顶部](#目录)

-------