title: 动态规划专题学习
author: Monody12
tags:
  - dynamic programming
categories:
  - algorithm
date: 2021-04-19 17:32:00
---
## 动态规划
-------
### 目录
1. 什么是动态规划
2. 什么情况下使用动态规划
3. 动态规划的解题步骤
4. 一些例题
--------------

## 1. 什么是动态规划
以下一些资料引用自[百度百科](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin)  
动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。多阶段决策问题：可将过程分成若干个**互相联系**的阶段，在它的**每一阶段**都需要作出决策，从而使整个过程达到最好的活动效果。  
各个阶段采取的决策，与时间有关、决策依赖于当前状态，又随即**引起状态的转移**，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义。

## 2. 什么情况下使用动态规划

看来以上对动态规划的定义，新接触的读者可能会一脸茫然，不过这也正常。因为教科书上的定义通常是抽象的，所以才需要加以解释才能通俗地理解。  
为什么要用动态规划？搜索不也可以解决类似的问题吗。没错，这个问题问的好。因为搜索通常会对一些步骤反复的计算。举一个例子吧！

给你一个数列（数列的项数从0开始），数列的前两项是0、1，往后的每一项都是它前两项的数值和。请编写一个求它任意项数值的程序。  

```c
int f(int n) {
    if (n == 0)
        return 0;
    else if (n == 1)
        return 1;
    return f(n - 1) + f(n - 2);  //等于它前两项的数值和
}
```

相信读者们一眼就看出这是一个斐波那契数列的递归搜索版本。我们来看一下它的运算过程。
![递归求斐波那契数列.jpg](https://i.loli.net/2021/04/19/Km4nI1MJciOslEo.jpg)

天啊，这树形的计算量，时间复杂度为O(2<sup>n</sup>)。存在很多冗余的计算——重复的子问题。这也是为什么要用动态规划的原因，我们可以很快的想出和理解斐波那契数列的推导公式`F(n)=f(n-1)+f(n-2)`。在空间花费量可以接受的前提下，我们要合理地去利用空间去换时间。很容易想到：我们可以将每次计算出来的结果存入数组，以后用到它的时候就直接从数组中取出来用不就行了。

这里可能有些读者会想到：这不是记忆化搜索吗？如果你继续使用递归来求解，这个方法也是可取的。下面我们来引入今天的主题：不用搜索、基于迭代循环的**动态规划算法**。


## 3.动态规划的解题步骤

参考自我的动态规划老师——[Carl的解决方案](https://mp.weixin.qq.com/s/ocZwfPlCWrJtVGACqFNAag)。

### 1. 确定dp数组以及下标的含义
为了一眼看出这是一个动态规划做法，我们暂且使用dp来代替f作为数组的名称。  
dp[n]表示数列的第n项的值。  
注：当我们写动态规划题迷茫的时候就问自己，我的dp数组的含义是什么。

### 2. 确定递推公式
通过上面的分析，或者是熟悉斐波那契数列的你一眼就看出来了。  
dp[n]=f[n-1]+f[n-2]

### 3. dp数组如何初始化
根据规定，数列的第一项和第二项分别为0和1。  
所以`dp[0]=0,dp[1]=1;`

### 4. 确定遍历顺序
因为斐波那契数列的项都是由它的前两项所得出的，所以遍历顺序为从前往后。

### 5. 举例推导dp数组
打印出dp数组在推导时的过程数组，检查其是否与自己思考的是否相符。  
注：找bug关键的一步。

至此，这一题我们就写出来了。之所以选用这么简单的例题，是为了能够让读者更专注与理解动态规划的思想和解题步骤，而不是专注于怎么求出一个很难的递推过程。  
题外话：其实这题还有更优的解法，使用两个变量不断更新作为当前要求的数列项的前两项值。但这样做就不能很好地理解动态规划了！

[原题链接](https://leetcode-cn.com/problems/fibonacci-number/)

参考代码：
```c++
class Solution {
public:
    int fib(int n) {
        long long f[31] = {0, 1};
        for (int i = 2; i <= n; ++i) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[n];
    }
};
```

## 4. 一些例题

暂未更新。
